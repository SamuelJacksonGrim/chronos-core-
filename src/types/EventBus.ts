// EventBus: light-weight pub/sub with autogenerated event ids, metadata, and simple arrow/event name synthesis

import { ChronosEvent, EventMeta } from '../types/index.js';

type Subscriber<T = any> = (evt: ChronosEvent<T>) => void;

export class EventBus {
  private subs: Map<string, Set<Subscriber>> = new Map();

  // generate a compact event id
  static generateId(prefix = 'evt') {
    const ts = Date.now().toString(36);
    const r = cryptoRandomHex(6);
    return `${prefix}-${ts}-${r}`;
  }

  // synthesize event name from payload or type hint
  static synthesizeName(base = 'event', payload?: any) {
    if (!payload) return base;
    if (typeof payload === 'string') {
      return `${base}:${payload.slice(0, 16).replace(/\s+/g, '_')}`;
    }
    if (payload?.type) return `${base}:${String(payload.type)}`.slice(0, 64);
    return `${base}:auto`;
  }

  subscribe<T = any>(topic: string, fn: Subscriber<T>) {
    if (!this.subs.has(topic)) this.subs.set(topic, new Set());
    this.subs.get(topic)!.add(fn as Subscriber);
    return () => this.unsubscribe(topic, fn);
  }

  unsubscribe<T = any>(topic: string, fn: Subscriber<T>) {
    this.subs.get(topic)?.delete(fn as Subscriber);
  }

  publish<T = any>(topic: string, payload?: T, source?: string) {
    const meta: EventMeta = {
      id: EventBus.generateId(topic),
      name: EventBus.synthesizeName(topic, payload),
      timestamp: new Date().toISOString(),
      source,
      payloadSummary: summarizePayload(payload)
    };

    const evt: ChronosEvent<T> = { meta, payload: payload as T };

    // deliver to exact topic subscribers
    (this.subs.get(topic) || new Set()).forEach(fn => {
      try { fn(evt); } catch (e) { console.error("Event handler error:", e); }
    });

    // wildcard delivery: topics like 'system.*' — deliver to matching keys
    for (const [key, set] of this.subs.entries()) {
      if (key.includes('*')) {
        const reg = new RegExp('^' + key.replace(/\*/g, '.*') + '$');
        if (reg.test(topic)) {
          set.forEach(fn => { try { fn(evt); } catch (e) { console.error("Event handler error:", e); }});
        }
      }
    }

    return evt;
  }

  // small helper: produce arrow label / event suggestion
  static arrowLabel(evt: EventMeta) {
    return `${evt.name} — ${new Date(evt.timestamp).toLocaleTimeString()}`;
  }
}

// helpers
function cryptoRandomHex(len: number) {
  const u = new Uint8Array(len);
  if (typeof crypto !== 'undefined' && 'getRandomValues' in crypto) {
    crypto.getRandomValues(u);
  } else {
    // node fallback
    const r = require('crypto');
    return r.randomBytes(len).toString('hex');
  }
  return Array.from(u).map(b => b.toString(16).padStart(2, '0')).join('');
}

function summarizePayload(p: any) {
  try {
    if (p == null) return 'null';
    if (typeof p === 'string') return p.length > 64 ? p.slice(0, 61) + '...' : p;
    if (typeof p === 'object') return Object.keys(p).slice(0, 6).join(',');
    return String(p);
  } catch { return 'summary_err'; }
}
